---
layout: post
title:  "람다식(Lamda)"
date:   2024-03-10 22:00:00 +0900
tags: [java,Lamda]
lastmod : 2024-03-10 22:00:00 +0900
sitemap :
  changefreq : daily
  priority : 1.0
---

# 람다식 사용 방법
## 전제 조건
단 한개의 **추상 메서드**만 가지는 인터페이스 필요

interface
```java
public interface MaxNumber {
	int getMax(int num1, int num2);
}
```

AS-IS
```java
MaxNumber maxNumber = new MaxNumber() {
	@Override
	public int getMax(int num1, int num2) {
		return num1 >= num2 ? num1 : num2;
	}
};

maxNumber.getMax(100, 101);
```

TO-BE
```java
MaxNumber maxNumber = (x,y)->(x>=y) ? x:y;
maxNumber.getMax(100, 101);
```

`(자료형 매개변수명,...) ->{실행문;};` 으로 new 하는 과정을 짧게 생략할 수 있다.<br>
<br>
`(x,y)` : 매개변수 (매개변수의 자료형 생략됨)<br>
`(x>=y) ? x:y;` : 실행문 (함수 몸체에 실행문이 1개이고, 실행문 자체를 return했기에 중괄호와 return 생략됨-즉 실행문이 여러개이면 대괄호를 써서 여러개를 나열하면 됨)<br>
<br>
+매개변수가 1개일경우에는 소괄호도 생략 가능<br>

```java
public interface MaxNumber{
	int getMax(int num1);
}
//=>
MaxNumber maxNumber = x->(x>= 1) ? x:0;
```

이전에 매개변수가 2개였을 때 `(x,y)` 가 `x` 한개가 되자 소괄호가 생략됨
<br>
<br>


# 람다를 사용하면 어떤 개선점을 얻을 수 있나요?
1. 코드가 간결해짐 (가독성)
2. 함수를 만들 필요 없어 생산성이 좋아진다.
3. 병렬 프로그램에 용이하다. - 일반적으로 다중 cpu를 활용하는 형태로 구현되어 병렬 처리에 유리함.

# 람다 사용 시 유의사항 및 단점
1. 가독성이 떨어질 수 있다.
2. 디버깅이 어렵다 - 람다 자체가 내부적으로 수행하는게 많아 오류 메시지가 많아지며, 수행하는게 많은 이유로 성능이 떨어질 수 있다.
3. 함수의 중복이 많을 수 있다.
4. 재귀에 부적합


# `@FunctionalInterface`
추상 메서드가 오직 하나인 인터페이스를 함수형 인터페이스라고 한다.
```java
interface TestInterface() {  // 추상 메서드를 오직 하나만 가지는 인터페이스
	T testCall();  // 구현체가 없는 추상 메서드
}
```

위와같이 인터페이스를 생성 할 경우 `@FunctionalInterface` 어노테이션이 없어도 함수형 인터페이스가 되지만,<br>
어노테이션을 이용하면 이후 유지보수 시 함수형 인터페이스 조건이 맞지 않게 될 때 빌드 오류로 캐치할  수 있게 된다. <br>
<br>
함수형 인터페이스를 매번 만들어 사용 할 필요가 없다.<br>
Java에서 제공되는 Functional Interface 들을 이용할 수 있다.<br>



| 인터페이스명        | 람다표현           | 메서드                       |
| ------------- | -------------- | ------------------------- |
| Predicate     | `T -> boolean` | `boolean test(T t)`       |
| Consumer      | `T -> void`    | `void accept(T t)`        |
| Supplier      | `() -> T`      | `T get()`                 |
| Function<T,R> | `T -> R`       | `R apply(T t)`            |
| Comparator    | `(T,T) -> int` | `int compare(T o1, T o2)` |
| Runnable      | `() -> void`   | `void run()`              |
| Callable      | `() -> V`      | `V call()`                |

<br>
대부분의 기능을 지원하기 때문에 Java 기본 함수형 인터페이스를 이용하면 인터페이스를 따로 생성하지 않아도 된다.<br>

# 람다를 이용한 사례 ( 샘플 코드 포함 )
```java
// 실제 사용중인 코드
userRepository.findUserById(id)
    .orElseThrow(() -> new CustomThrowable("사용자 정보가 존재하지 않습니다."));
```
<br><br>

---
# 더블콜론(::)

1. 람다 표현식이 단 하나의 메서드만을 호출하는 경우
2. 람다 표현식이 단순히 객체를 생성하고 반환하는 경우

## 문법
클래스이름::메소드이름<br>
참조변수이름::메소드이름<br>

<br>

메서드를 참조하는 경우
```java
List<String> list = Arrays.asList("first", "second", "third", "forth");
list.forEach(item -> System.out.println(item)); // 기본 람다식
list.forEach(System.out::println); // :: 문법
// 콘솔 로그 결과 동일
```

<br>

생성자를 참조하는 경우
```java
Function<String, Food> function1 = (String a) -> new Food(a); // 람다식
Function<String, Food> function2 = Food::new; // :: 문법
```

<br>

```java
private List<ApplicationWarmer> applicationWarmers;

Optional.ofNullable(applicationWarmers)  // List 객체
    .orElseGet(Collections::emptyList)  // applicationWarmers가 비어있으면 빈 list 사용
    .forEach(this::warmup);  // warmup() 메서드를 위 리스트 사이즈만큼 for문 돌면서 호출

// Collections::emptyList 의미는 emptyList 라는 메서드를 호출함
public static final <T> List<T> emptyList() {
    return (List<T>) EMPTY_LIST;
}
```

